"""
Data loader for TorchSig-generated RF datasets.

Provides a plugin-compatible data loader for RF datasets generated
using TorchSigGenerator or the TorchSig library directly.
"""

import json
from pathlib import Path
from typing import List, Dict, Optional, Any

import numpy as np
import pandas as pd

from src.registry import data_loader_registry
from src.data.base import BaseDataLoader


@data_loader_registry.register("torchsig", version="1.0")
class TorchSigDataLoader(BaseDataLoader):
    """
    Data loader for TorchSig-generated RF datasets.

    Loads RF datasets generated by TorchSigGenerator with support for:
    - IQ data (.npy files)
    - Precomputed spectrograms (.npy and .png)
    - Metadata CSV with modulation labels
    - Configuration from generation

    Expected directory structure:
        dataset_root/
        ├── config.json           # Generation configuration
        ├── metadata.csv          # Sample metadata
        ├── generation_info.json  # Generation statistics
        ├── iq/                   # IQ data files
        │   ├── sample_000000.npy
        │   └── ...
        ├── spectrograms/         # Spectrogram .npy files
        │   ├── sample_000000.npy
        │   └── ...
        └── spectrograms_png/     # Spectrogram PNG files
            ├── sample_000000.png
            └── ...

    Args:
        data_root: Root directory of the generated dataset
        use_spectrograms: Use spectrograms as primary data (default: True)
        spectrogram_format: 'npy' or 'png' (default: 'npy')

    Example:
        loader = data_loader_registry.create(
            "torchsig",
            data_root=Path("data/rf_datasets/my_dataset")
        )
        metadata = loader.load_metadata()
        sample_paths = loader.get_sample_paths()
    """

    def __init__(
        self,
        data_root: Path,
        use_spectrograms: bool = True,
        spectrogram_format: str = "npy",
        **kwargs
    ):
        super().__init__(data_root, **kwargs)
        self.use_spectrograms = use_spectrograms
        self.spectrogram_format = spectrogram_format

        # Determine data directories
        self.iq_dir = self.data_root / "iq"
        self.spectrogram_dir = self.data_root / "spectrograms"
        self.spectrogram_png_dir = self.data_root / "spectrograms_png"
        self.metadata_file = self.data_root / "metadata.csv"
        self.config_file = self.data_root / "config.json"

        # Load generation config if available
        self._generation_config = None
        if self.config_file.exists():
            with open(self.config_file) as f:
                self._generation_config = json.load(f)

    @property
    def generation_config(self) -> Optional[Dict[str, Any]]:
        """Get the configuration used to generate this dataset."""
        return self._generation_config

    @property
    def modulations(self) -> List[str]:
        """Get list of modulation types in dataset."""
        if self._generation_config:
            return self._generation_config.get('modulations', [])
        # Fall back to reading from metadata
        try:
            df = pd.read_csv(self.metadata_file)
            return sorted(df['label'].unique().tolist())
        except Exception:
            return []

    @property
    def sample_rate(self) -> float:
        """Get sample rate of the dataset."""
        if self._generation_config:
            return self._generation_config.get('sample_rate', 10e6)
        return 10e6

    @property
    def num_iq_samples(self) -> int:
        """Get number of IQ samples per signal."""
        if self._generation_config:
            return self._generation_config.get('num_iq_samples', 4096)
        return 4096

    def load_metadata(self) -> pd.DataFrame:
        """
        Load dataset metadata with standard schema.

        Returns:
            DataFrame with columns:
            - filepath: Path to sample file (spectrogram or IQ)
            - label: Modulation type
            - lat, lon: Geographic coordinates (NaN for RF data)
            - Additional: target, modulation, snr_db, sample_rate, etc.
        """
        if not self.metadata_file.exists():
            raise FileNotFoundError(f"Metadata file not found: {self.metadata_file}")

        df = pd.read_csv(self.metadata_file)

        # Determine primary data directory
        if self.use_spectrograms:
            if self.spectrogram_format == "png":
                data_dir = self.spectrogram_png_dir
                ext = ".png"
            else:
                data_dir = self.spectrogram_dir
                ext = ".npy"
        else:
            data_dir = self.iq_dir
            ext = ".npy"

        # Build filepath column
        df['filepath'] = df['filename'].apply(
            lambda x: str(data_dir / x.replace('.npy', ext))
        )

        # Add IQ filepath as additional field
        df['iq_filepath'] = df['filename'].apply(
            lambda x: str(self.iq_dir / x)
        )

        # Add spectrogram filepath if using IQ as primary
        if not self.use_spectrograms:
            df['spectrogram_filepath'] = df['filename'].apply(
                lambda x: str(self.spectrogram_dir / x)
            )

        # Ensure label column exists
        if 'label' not in df.columns and 'modulation' in df.columns:
            df['label'] = df['modulation']

        # Add geographic columns (NaN for RF - no location data)
        if 'lat' not in df.columns:
            df['lat'] = np.nan
        if 'lon' not in df.columns:
            df['lon'] = np.nan

        return df

    def get_sample_paths(self) -> List[Path]:
        """
        Get list of all sample file paths.

        Returns:
            List of paths to sample files (spectrograms or IQ data)
        """
        if self.use_spectrograms:
            if self.spectrogram_format == "png":
                return sorted(self.spectrogram_png_dir.glob("*.png"))
            else:
                return sorted(self.spectrogram_dir.glob("*.npy"))
        else:
            return sorted(self.iq_dir.glob("*.npy"))

    def get_iq_paths(self) -> List[Path]:
        """Get list of IQ data file paths."""
        return sorted(self.iq_dir.glob("*.npy"))

    def get_spectrogram_paths(
        self,
        spectrogram_dir: Optional[Path] = None
    ) -> Dict[str, Path]:
        """
        Get mapping from sample filename to spectrogram path.

        Args:
            spectrogram_dir: Override spectrogram directory

        Returns:
            Dict mapping sample filename to spectrogram path
        """
        spec_dir = spectrogram_dir or self.spectrogram_dir
        spec_dir = Path(spec_dir)

        mapping = {}
        for iq_path in self.get_iq_paths():
            spec_path = spec_dir / iq_path.name
            if spec_path.exists():
                mapping[iq_path.name] = spec_path

        return mapping

    def load_sample(
        self,
        filename: str,
        load_iq: bool = True,
        load_spectrogram: bool = True
    ) -> Dict[str, Any]:
        """
        Load a single sample with IQ data and/or spectrogram.

        Args:
            filename: Sample filename (e.g., 'sample_000000.npy')
            load_iq: Load IQ data
            load_spectrogram: Load spectrogram

        Returns:
            Dict with 'iq', 'spectrogram', and 'metadata' keys
        """
        result = {}

        if load_iq:
            iq_path = self.iq_dir / filename
            if iq_path.exists():
                result['iq'] = np.load(iq_path)

        if load_spectrogram:
            spec_path = self.spectrogram_dir / filename
            if spec_path.exists():
                result['spectrogram'] = np.load(spec_path)

        # Load metadata for this sample
        df = pd.read_csv(self.metadata_file)
        sample_meta = df[df['filename'] == filename]
        if not sample_meta.empty:
            result['metadata'] = sample_meta.iloc[0].to_dict()

        return result

    def get_class_distribution(self) -> Dict[str, int]:
        """Get distribution of samples per class."""
        df = pd.read_csv(self.metadata_file)
        return df['label'].value_counts().to_dict()

    def get_info(self) -> Dict[str, Any]:
        """
        Get comprehensive dataset information.

        Returns:
            Dict with dataset statistics and configuration
        """
        base_info = super().get_info()

        # Add RF-specific information
        base_info.update({
            'modulations': self.modulations,
            'sample_rate': self.sample_rate,
            'num_iq_samples': self.num_iq_samples,
            'has_iq_data': self.iq_dir.exists() and any(self.iq_dir.glob("*.npy")),
            'has_spectrograms': self.spectrogram_dir.exists() and any(self.spectrogram_dir.glob("*.npy")),
            'has_png_spectrograms': self.spectrogram_png_dir.exists() and any(self.spectrogram_png_dir.glob("*.png")),
        })

        # Add generation config info
        if self._generation_config:
            base_info['generation_config'] = {
                'impairment_level': self._generation_config.get('impairment_level'),
                'snr_range': [
                    self._generation_config.get('snr_db_min'),
                    self._generation_config.get('snr_db_max'),
                ],
            }

        return base_info

    def validate(self) -> tuple:
        """
        Validate dataset integrity.

        Returns:
            Tuple of (is_valid, error_messages)
        """
        is_valid, errors = super().validate()

        # Additional RF-specific validation
        if not self.metadata_file.exists():
            errors.append(f"Metadata file not found: {self.metadata_file}")
            is_valid = False

        # Check for data files
        if self.use_spectrograms:
            if self.spectrogram_format == "png":
                if not self.spectrogram_png_dir.exists():
                    errors.append("PNG spectrogram directory not found")
                    is_valid = False
            else:
                if not self.spectrogram_dir.exists():
                    errors.append("Spectrogram directory not found")
                    is_valid = False
        else:
            if not self.iq_dir.exists():
                errors.append("IQ data directory not found")
                is_valid = False

        # Validate metadata columns
        if self.metadata_file.exists():
            df = pd.read_csv(self.metadata_file)
            required_cols = ['filename', 'label', 'target']
            missing = [c for c in required_cols if c not in df.columns]
            if missing:
                errors.append(f"Missing metadata columns: {missing}")
                is_valid = False

        return is_valid, errors


@data_loader_registry.register("torchsig_iq", version="1.0")
class TorchSigIQDataLoader(TorchSigDataLoader):
    """
    Data loader for TorchSig datasets using IQ data as primary.

    Convenience subclass that defaults to using IQ data instead of
    spectrograms. Useful when you want to apply custom transforms
    to the raw IQ samples.

    Example:
        loader = data_loader_registry.create(
            "torchsig_iq",
            data_root=Path("data/rf_datasets/my_dataset")
        )
    """

    def __init__(self, data_root: Path, **kwargs):
        kwargs['use_spectrograms'] = False
        super().__init__(data_root, **kwargs)


@data_loader_registry.register("torchsig_png", version="1.0")
class TorchSigPNGDataLoader(TorchSigDataLoader):
    """
    Data loader for TorchSig datasets using PNG spectrograms.

    Convenience subclass for FiftyOne visualization workflows
    that require PNG images as primary media.

    Example:
        loader = data_loader_registry.create(
            "torchsig_png",
            data_root=Path("data/rf_datasets/my_dataset")
        )
    """

    def __init__(self, data_root: Path, **kwargs):
        kwargs['use_spectrograms'] = True
        kwargs['spectrogram_format'] = 'png'
        super().__init__(data_root, **kwargs)
